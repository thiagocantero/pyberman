#GameObjects.py#Copyright (C) 2011 PyTeam"""Module which contains main classes such as Bonus, Wall, Box, Player and levelLoads necessary images from Data folderVersion 1.0Needs:- rewrite all paths from absolute to relative- add all bonuses- add bomb class- add functionality to player"""import osimport pygamefrom pyberman import GameIMAGE_DIR = "data"class GameObject(pygame.sprite.Sprite):    """The base class for all visible entities in the game, which implements generic operations.    See the base class documentation at http://pygame.org/docs/ref/sprite.html#pygame.sprite    """    #: list of file names of images to load    image_files=[]    def __init__(self, x,y, groups=None):        self.x = x        self.y = y        super(GameObject, self).__init__(*(groups if groups is not None else []))        self.images=[]        if self.image_files:            for f in self.image_files:                self.images.append(GameObject.load_image(f))        if self.images:            self.image=self.images[0]    def update(self):        """Updates the object's state.        It is called on each core frame."""        if self.image is not None:            self.rect = self.image.get_rect(center=(self.screen_x, self.screen_y))    @staticmethod    def load_image(file_name):        return pygame.image.load(os.path.join(IMAGE_DIR, file_name))    @property    def screen_x(self):        return Game.instance().level.xcoord_to_screen(self.x)    @property    def screen_y(self):        return Game.instance().level.ycoord_to_screen(self.y)    def collide(self, other):        """By default, it searches a method named 'collide_otherclassname' and calls it if exist.        for example, if object implements method named 'collide_Player', it would be called when player collides with this object.        @returns: whether the movement can be continued        @rtype: bool        """        func = getattr(self, 'collide_%s'%other.__class__.__name__, None)        if func is not None:            return func(other)  class Bonus(GameObject):    """Represents an item which affects the player on collision and then disappears."""    def collide_Player(self, player):        self.affect_player(player)        self.kill()        return True #Player can move further    def affect_player(self, player):        """Makes something fun with player.        Should be overloaded in derived classes."""        passclass SpeedupBonus(Bonus):    """Speeds the player up by a factor."""    image_files=['1.jpg']    def affect_player(self, player):        #To be done        passclass Wall(GameObject):    """An obstacle which player can not get through."""    image_files = ['wall.jpg']    def collide_Player(self, player):        return False #player can not move furtherclass Box(Wall):    """An obstacle which can be ruined by a bomb explosion."""    image_files = ['box.jpg']    def collide_BombExplosion(self):        self.kill()        return Trueclass Player(GameObject):    """Represents a player in the game."""    player_images = ['1.jpg', '2.jpg', '3.jpg']    def __init__(self, x, y, id, *args, **kwargs):        self.id = id        self.bombs = 1        self.speed=5        self.radius=1        super(Player, self).__init__(x,y, *args, **kwargs)        self.image = GameObject.load_image(Player.player_images[id])class Level(object):    """Manages a game level.    It is responsilbe for loading and updating the level."""    def __init__(self, filename):        self.create_groups()        self.load_level(filename)#        self.background = pygame.Surface(game.surface.get_size()).convert()#        self.background.fill((100, 100, 100))#        game.surface.blit(self.background, self.background.get_rect())#        pygame.display.flip()    def load_level(self, filename):        with open(filename) as f:            self.height,self.width,self.max_players = [int(x) for x in f.readline().split()]            #Todo: make use of game.config['screen'] instead of hard-coding            self._absw = 400-(self.width*20)+20            self._absh = 300-(self.height*20)+20            for row_num, row in enumerate(f):                if row_num == self.height: raise RuntimeError('Too many lines in the file')                for col_num, col in enumerate(row.strip()):                    if col_num == self.width: raise RuntimeError('Too many colums in row %d'%row_num+1)                    if col == 'W':                        Wall(row_num, col_num, groups=(self.all, self.obstacles))                    elif col == 'B':                        Box(row_num, col_num, groups=(self.all, self.dynamic, self.obstacles))                    elif col == ' ':                         pass                    elif col.isdigit() and int(col)<10:                        Player(row_num, col_num, int(col)-1, groups=(self.all, self.dynamic))                    else:                        raise RuntimeError('Unknown symbol "%s" in row %d, col %d'%(col, row_num+1, col_num+1))                if col_num<self.width-1:                    raise RuntimeError('Insuficient number of colums in row %d'%row_num+1)            if row_num<self.height-1:                raise RuntimeError('Insuficient number of rows')    def xcoord_to_screen(self, x):        """Translates given x coordinate from the game coord system to screen coord system."""        return self._absw+x*20    def ycoord_to_screen(self, y):        """Translates given y coordinate from the game coord system to screen coord system."""        return self._absh+y*20    def create_groups(self):        self.all = pygame.sprite.RenderUpdates()        self.obstacles = pygame.sprite.Group()        self.dynamic = pygame.sprite.Group() #those objects which may progress over time    def draw(self, surface):        """Redraws the level. It is called each core pumb"""        self.all.draw(surface)    def update(self):        self.all.update()